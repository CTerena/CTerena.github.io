<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://CTerena.github.io</id>
    <title>停云</title>
    <updated>2021-10-18T00:33:42.859Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://CTerena.github.io"/>
    <link rel="self" href="https://CTerena.github.io/atom.xml"/>
    <subtitle>尽道清歌传皓齿，风起，雪飞炎海变清凉</subtitle>
    <logo>https://CTerena.github.io/images/avatar.png</logo>
    <icon>https://CTerena.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, 停云</rights>
    <entry>
        <title type="html"><![CDATA[常用字典常量和操作]]></title>
        <id>https://CTerena.github.io/post/chang-yong-zi-dian-chang-liang-he-cao-zuo/</id>
        <link href="https://CTerena.github.io/post/chang-yong-zi-dian-chang-liang-he-cao-zuo/">
        </link>
        <updated>2021-10-17T01:08:18.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<!-- more -->
<!-- more -->
<!-- more -->
<!-- more -->
<!-- more -->
<!-- more -->
<!-- more -->
<!-- more -->
<!-- more -->
<!-- more -->
<!-- more -->
<p><code>D = {}</code>        空字典</p>
<p><code>D = {'spam' : 2, 'eggs' : 3}</code>    两项目字典</p>
<p><code>D = {'food' : {'ham' : 1, 'eggs' : 2}}</code>   字典嵌套</p>
<p><code>D = dict(zip(keyslist, valslist))</code>  关键字、对应的对、键列表</p>
<p><code>D = (name = 'Bob' , age = 42)</code></p>
<p><code>D['Bob']</code>  以键为索引运算</p>
<p><code>D['food']['eggs']</code></p>
<p><code>'eggs' in D</code> 成员关系：键存在测试</p>
<p><code>D.keys()</code> 返回dict_keys类型数据</p>
<p><code>D.values()</code> 值</p>
<p><code>D.items()</code> 键 + 值</p>
<p><code>D.copy()</code> 副本</p>
<!-- more -->
<p>示例：</p>
<pre><code class="language-cpp">dic = {'yi' : 1, 'er' : 2}
print(dic.keys())
print(dic.values())
print(dic.items())
print(dic.copy())
</code></pre>
<p>输出：</p>
<pre><code class="language-cpp">dict_keys(['yi', 'er'])
dict_values([1, 2])
dict_items([('yi', 1), ('er', 2)])
{'yi': 1, 'er': 2}
</code></pre>
<!-- more -->
<p>更多：<br>
<code>D.update(D2)</code> 合并</p>
<p><code>D.pop(key)</code> 删除一个键并返回它的值</p>
<p><code>len(D)</code> 长度（项目数目）</p>
<p><code>D[key] = 12</code> 新增/修改键</p>
<p><code>del D[key]</code> 根据键删除项目</p>
<p><code>list(D.keys())</code> 字典视图</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[神经网络入门]]></title>
        <id>https://CTerena.github.io/post/shen-jing-wang-luo-ru-men/</id>
        <link href="https://CTerena.github.io/post/shen-jing-wang-luo-ru-men/">
        </link>
        <updated>2021-10-09T08:57:53.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<!-- more -->
<!-- more -->
<!-- more -->
<!-- more -->
<!-- more -->
<!-- more -->
<!-- more -->
<!-- more -->
<!-- more -->
<!-- more -->
<!-- more -->
<!-- more -->
<!-- more -->
<!-- more -->
<h1 id="part-1-阶跃函数的实现">Part 1. 阶跃函数的实现</h1>
<pre><code class="language-cpp">def step_function(x):
    y = x &gt; 0
    return y.astype(np.int)
</code></pre>
<p>原理示例：</p>
<pre><code class="language-cpp">import numpy as np

def step_function(x):
    y = x &gt; 0
    return y.astype(np.int)

x = np.array([-1.0, 1.0, 2.0])
y = x &gt; 0
print(y) #输出结果：[False  True  True]
</code></pre>
<p>对Numpy数组进行不等号运算时，数组的各个元素都会进行不等号运算，生成一个布尔型数组，进而用<code>astype()</code>方法将布尔型转换为int型即可得到我们想要的阶跃函数（输出int型的0或1的函数）</p>
<p>获取阶跃函数的图形：</p>
<pre><code class="language-cpp">import numpy as np
import matplotlib.pylab as plt

def step_function(x):
    return np.array(x &gt; 0, dtype = np.int)

x = np.arange(-5.0, 5.0, 0.1)
y = step_function(x)
plt.plot(x, y)
plt.ylim(-0.1, 1.1)
plt.show()
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://CTerena.github.io/post-images/1633770470145.png" alt="" loading="lazy"></figure>
<!-- more -->
<h1 id="part-2-sigmoid函数的实现">Part 2. sigmoid函数的实现</h1>
<pre><code class="language-cpp">def sigmoid(x):
    return 1 / (1 + np.exp(-x))
</code></pre>
<p>借助Numpy的广播功能，sigmoid函数可支持Numpy数组的运算</p>
<!-- more -->
<p>获取sigmoid函数图形：</p>
<pre><code class="language-cpp">import numpy as np
import matplotlib.pylab as plt

def sigmoid(x):
    return 1 / (1 + np.exp(-x))

x = np.arange(-5.0, 5.0, 0.1)
y = sigmoid(x)
plt.plot(x,y)
plt.show()
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://CTerena.github.io/post-images/1633770889449.png" alt="" loading="lazy"></figure>
<h2 id="sigmoid函数和阶跃函数的比较">sigmoid函数和阶跃函数的比较</h2>
<ol>
<li>与阶跃函数不同，sigmoid函数图像是一条平滑的曲线，该平滑性对神经网络的学习具有重要意义。</li>
<li>相对于阶跃函数只能返回0或1，sigmoid函数可以返回连续的实数值信号。</li>
<li>两函数的共同点在于，当输入信号为重要信息（接近1）时，阶跃函数和sigmoid函数都会输出较大的值；当输出信号为不重要的信息时，两者都输出较小的值。另外一个共同点是，输出信号的值始终在0到1之间</li>
</ol>
<!-- more -->
<h1 id="part-3-relu函数的实现">Part 3. ReLU函数的实现</h1>
<pre><code class="language-cpp">def relu(x):
    return np.maximum(0,x)
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://CTerena.github.io/post-images/1633771491628.png" alt="" loading="lazy"></figure>
<h1 id="part-4-神经网络的内积">Part 4. 神经网络的内积</h1>
<p>示例：用NumPy矩阵实现神经网络（省略偏置与激活函数，只有权重）<br>
<img src="https://CTerena.github.io/post-images/1633775670115.png" alt="" loading="lazy"></p>
<pre><code class="language-cpp">import numpy as np

X = np.array([1,2])
W = np.array([[1, 3, 5], [2, 4, 6]])

Y = np.dot(X, W)
print(Y)
</code></pre>
<h1 id="part-5-3层神经网络的实现">Part 5. 3层神经网络的实现</h1>
<figure data-type="image" tabindex="4"><img src="https://CTerena.github.io/post-images/1633775953786.png" alt="" loading="lazy"></figure>
<h2 id="1-从定义符号开始">1. 从定义符号开始：</h2>
<p><img src="https://CTerena.github.io/post-images/1633776090499.png" alt="" loading="lazy"><br>
如图，权重和隐藏层的神经元右上角有一个&quot;(1)&quot;，它表示权重和神经元的层号（即第一层的权重、第一次的神经元）。此外，权重右下角有两个数字，它们是后一层的神经元和前一层的神经元的索引号，按照“后一层的索引号、前一层的索引号”的顺序排列。</p>
<!-- more -->
<h2 id="2-各层间信号传递的实现">2. 各层间信号传递的实现</h2>
<p><img src="https://CTerena.github.io/post-images/1633776270775.png" alt="" loading="lazy"><br>
现在进行从输入层到第一层的第一个神经元的信号传递过程（增加了表示偏置的神经元&quot;1&quot;)可以注意到偏置右下角的索引号只有一个，这是由于前一层只有一个偏置神经元<br>
由前所述，现在通过加权信号和偏置的和按如下方式进行计算：</p>
<!-- more -->
<p><strong>a<sub>1</sub><sup>(1)</sup>=w<sub>11</sub><sup>(1)</sup>x<sub>1</sub>+w<sub>12</sub><sup>(1)</sup>x<sub>2</sub>+b<sub>1</sub><sup>(1)</sup></strong><br>
此外，如果使用矩阵的乘法运算，则可以将第一层的加权和表示成下式：<br>
<strong>A<sup>(1)</sup>=XW<sup>(1)</sup>+B<sup>(1)</sup></strong><br>
其中<br>
<img src="https://CTerena.github.io/post-images/1633776861616.png" alt="" loading="lazy"><br>
下面用NumPy多维数组来实现上式，这里将输入信号、权重和偏置设置为任意值</p>
<pre><code class="language-cpp">x = np.array([1.0, 0.5])
w1 = np.array([[0.1, 0.3, 0.5], [0.2, 0.4, 0.5]])
b1 = np.array([0.1, 0.2, 0.3])

a1 = np.dot(x, w1) + b1 #a1 = [0.3 0.7 1.1]
</code></pre>
<p>接下来，观察第一层中激活函数的计算过程。该过程可由下图表示<br>
<img src="https://CTerena.github.io/post-images/1633777156190.png" alt="" loading="lazy"><br>
如图所示，隐藏层的加权和用a表示，被激活函数转换后的信号用z表示。此外，图中h()表示激活函数，这里我们使用sigmoid函数。<br>
<code>z1 = sigmoid(a1) #z1 = [0.57444252 0.66818777 0.75026011]</code><br>
下面，进行第一层到第二层的信号传递（如图所示）<br>
<img src="https://CTerena.github.io/post-images/1633777516340.png" alt="" loading="lazy"></p>
<pre><code class="language-cpp">w2 = np.array([[0.1, 0.4], [0.2, 0.5], [0.3, 0.6]])
b2 = np.array([0.1, 0.2])
a2 = np.dot(z1, w1) + b2
z2 = sigmoid(a2)
</code></pre>
<p>除了第一层的输出（z1）变为第二层的输入（a2）这一点外，这部分代码与前一部分完全相同。</p>
<!-- more -->
<p>最后是第二层到输出层的信号传递。输出层的实现也和之前的实现基本相同。不过，最后的激活函数和之前的隐藏层略有不同。<br>
<img src="https://CTerena.github.io/post-images/1633777886238.png" alt="" loading="lazy"></p>
<pre><code class="language-cpp">def identity_function(x):
    return x

w3 = np.array([[0.1, 0.3], [0.2, 0.4]])
b3 = np.array([0.1, 0.2])

a3 = np.dot(z2, w3) + b3
y = identity_function(a3)
</code></pre>
<p>这里我们定义了identity_function()函数（恒等函数），并将其作为输出层的激活函数。（这里这样实现只是为了和之前的流程保持格式统一。</p>
<!-- more -->
<h2 id="代码整合小结">代码整合小结</h2>
<p>至此，3层神经网络的实现已经介绍完毕。下面，按照神经网络的实现惯例，我们将权重用大写字母表示，其余量用小写字母表示来整理代码：（类优化）</p>
<pre><code class="language-cpp">def identity_function(x):
    return x

def init_network():
    network = {}
    network['W1'] = np.array([[0.1, 0.3, 0.5], [0.2, 0.4, 0.6]])
    network['b1'] = np.array([0.1, 0.2, 0,3])
    network['W2'] = np.array([[0.1, 0.4], [0.2, 0.5], [0.3, 0.6]])
    network['b2'] = np.array([0.1, 0.2])
    network['W3'] = np.array([[0.1, 0.3], [0.2, 0.4]])
    network['b3'] = np.array([0.1, 0.2])
    return network

def forward(network, x):
    W1, W2, W3 = network['W1'], network['W2'], network['W3']
    b1, b2, b3 = network['b1'], network['b2'], network['b3']
    
    a1 = np.dot(x, W1) + b1
    z1 = sigmoid(a1)
    a2 = np.dot(z1, W2) + b2
    z2 = sigmoid(a2)
    a3 = np.dot(z2, W3) + b3
    y = identity_function(a3)
    
    return y

network = init_network()
x = np.array([1.0, 0.5])
y = forward(network, x)
print(y)
</code></pre>
<h1 id="part-6-输出层的设计">Part 6. 输出层的设计</h1>
<p>神经网络可以用在分类和回归问题上，不过需要根据情况改变输出层的激活函数。一般而言，回归问题用恒等函数，分类问题用softmax函数。</p>
<ul>
<li>回归问题可理解为“根据某个输入预测一个数值”的问题。</li>
</ul>
<!-- more -->
<h2 id="softmax函数">softmax函数</h2>
<p>分类问题中使用的softmax函数可用下式表示：<br>
<img src="https://CTerena.github.io/post-images/1633869664594.png" alt="" loading="lazy"><br>
该式表示假设输出层共有n个神经元，计算第k个神经元的输出y<sub>k</sub>。<br>
用图表示softmax函数：<br>
<img src="https://CTerena.github.io/post-images/1633869768645.png" alt="" loading="lazy"><br>
softmax函数实现：</p>
<pre><code class="language-cpp">import numpy as np
def softmax(a):
    exp_a = np.exp(a) #分子
    sum_exp_a = np.sum(exp_a) #分母
    y = exp_a / sum_exp_a #计算
    return y

a = [12.32, 3.67, 9.83]
print(softmax(a))
# [9.23288490e-01 1.61692603e-04 7.65498178e-02]
</code></pre>
<h2 id="注意事项">注意事项</h2>
<p>softmax函数的实现要进行指数函数的运算，指数函数的值很容易变得非常大。如果在这些超大数值之间进行除法运算，结果会出现“不确定”情况<br>
为避免这种问题，我们可以像对算式进行如下变形优化：<br>
<img src="https://CTerena.github.io/post-images/1633870346256.png" alt="" loading="lazy"></p>
<!-- more -->
<p>示例（未优化）：</p>
<pre><code class="language-cpp">import numpy as np
def softmax(a):
    exp_a = np.exp(a) #分子
    sum_exp_a = np.sum(exp_a) #分母
    y = exp_a / sum_exp_a #计算
    return y

a = np.array([1010, 1000, 990])

print(softmax(a))
'''
输出结果：
[nan nan nan]
C:\Users\Charles.Wen\untitled4.py:3: RuntimeWarning: overflow encountered in exp
  exp_a = np.exp(a) #分子
C:\Users\Charles.Wen\untitled4.py:5: RuntimeWarning: invalid value encountered in true_divide
  y = exp_a / sum_exp_a #计算
</code></pre>
<p>已优化：</p>
<pre><code class="language-cpp">import numpy as np
def softmax(a):
    exp_a = np.exp(a) #分子
    sum_exp_a = np.sum(exp_a) #分母
    y = exp_a / sum_exp_a #计算
    return y

a = np.array([1010, 1000, 990])
c = np.max(a)
a -= c
print(softmax(a))
#正常输出：[9.99954600e-01 4.53978686e-05 2.06106005e-09]
</code></pre>
<!-- more -->
<p>自动进行优化的softmax函数：</p>
<pre><code class="language-cpp">def softmax(a):
    c = np.max(a)
    exp_a = np.exp(a - c)
    sum_exp_a = np.sum(exp_a)
    y = exp_a / sum_exp_a
    return y
</code></pre>
<!-- more -->
<h2 id="softmax函数的特征">softmax函数的特征</h2>
<ol>
<li>softmax函数的输出是0.0到1.0之间的实数</li>
<li>softmax函数的输出值总和是1，正是有了这个性质，我们才可以把softmax函数的输出解释成“概率”</li>
</ol>
<h1 id="part-7-数字识别程序">Part 7. 数字识别程序</h1>
<p>该数字识别借助MNIST数字集实现，需要自行下载该资源到相应的地址，且权重、偏置包调用调配完毕的数据，从文件中导入即可。本程序仅实现测试数据即参数的导入与神经网络的向前计算过程</p>
<pre><code class="language-cpp">import numpy as np
import sys, os
sys.path.append(os.pardir)
from dataset.mnist import load_mnist
from PIL import Image
import pickle

def sigmoid(x):
    return 1 / (1 + np.exp(-x))

def softmax(a):
    c = np.max(a)
    exp_a = np.exp(a - c)
    sum_exp_a = np.sum(exp_a)
    y = exp_a / sum_exp_a
    return y

def get_data():
    (x_train, t_train), (x_test, t_test) = \
        load_mnist(normalize = True, flatten = True, one_hot_label = False)
    return x_test, t_test

def init_network():
    with open(&quot;sample_weight.pkl&quot;, 'rb') as f:
        network = pickle.load(f)
    return network

def predict(network, x):
    W1, W2, W3 = network['W1'], network['W2'], network['W3']
    b1, b2, b3 = network['b1'], network['b2'], network['b3']
    a1 = np.dot(x, W1) + b1
    z1 = sigmoid(a1)
    a2 = np.dot(z1, W2) + b2
    z2 = sigmoid(a2)
    a3 = np.dot(z2, W3) + b3
    y =softmax(a3)
    
    return y

x, t = get_data()
network = init_network()

accuracy_cnt = 0
for i in range(len(x)):
    y = predict(network, x[i])
    p = np.argmax(y)
    if p == t[i]:
        accuracy_cnt += 1
print(&quot;Accuracy:&quot; + str(float(accuracy_cnt) / len(x)))
</code></pre>
<!-- more -->
<h2 id="批处理优化">批处理优化</h2>
<p>批处理对计算机的计算大有益处，可以大幅缩短处理每张图像的平均用时。大多数处理数值计算的库都进行了能够高效处理大型数组运算的最优化。并且，在神经网络的运算中，当数据传送成为瓶颈，批处理可以减轻数据总线的负荷（严格地讲，相对于数据读入，可以将更多的时间用在计算上）。也就是说，批处理一次性计算大量数组要比分开逐步计算各个小型数组速度更快</p>
<!-- more -->
<p>代码实现：</p>
<pre><code class="language-cpp">x, t = get_data()
network = init_network

batch_size = 100

for i in range(0， len(x), batch_size):
    x_batch = x[i:i+batch_size]
    y_batch = predict(network, x_batch)
    p = np.argmax(y_batch, axis = 1)
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[感知机(perceptron)学习笔记]]></title>
        <id>https://CTerena.github.io/post/gan-zhi-ji-perceptronxue-xi-bi-ji/</id>
        <link href="https://CTerena.github.io/post/gan-zhi-ji-perceptronxue-xi-bi-ji/">
        </link>
        <updated>2021-10-09T08:07:06.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<!-- more -->
<!-- more -->
<!-- more -->
<!-- more -->
<!-- more -->
<!-- more -->
<!-- more -->
<!-- more -->
<!-- more -->
<!-- more -->
<!-- more -->
<!-- more -->
<!-- more -->
<!-- more -->
<!-- more -->
<h1 id="part-1-单层感知机">Part 1. 单层感知机</h1>
<ol>
<li>接收参数x<sub>1</sub>和x<sub>2</sub>的<code>AND</code>函数</li>
</ol>
<pre><code class="language-cpp">def AND(x1,x2):
    w1, w2, theta = 0.5, 0.5, 0.7
    tmp = x1 * w1 + x2 * w2
    if tmp &lt;=theta:
        return 0
    elif tmp &gt; theta:
        return 1
    
print(AND(0,0)) #0
print(AND(0,1)) #0
print(AND(1,0)) #0
print(AND(1,1)) #1
</code></pre>
<!-- more -->
<ol start="2">
<li>导入权重和偏置</li>
</ol>
<pre><code class="language-cpp">import numpy as np
x = np.array([0, 1])     #输入
w = np.array([0.5, 0.5]) #权重
b = -0.7                 #偏置
print(w * x)
print(np.sum(w * x))
print(np.sum(w * x) + b)
</code></pre>
<!-- more -->
<ol start="3">
<li>使用权重和偏置实现<code>AND</code>门</li>
</ol>
<pre><code class="language-cpp">import numpy as np
def AND(x1, x2):
    x = np.array([x1, x2])     #输入
    w = np.array([0.5, 0.5]) #权重
    b = -0.7                 #偏置
    flg = np.sum(w * x)
    if np.sum(w * x) + b &gt; 0:
        return 1
    else:
        return 0
    
print(AND(0,0)) #0
print(AND(0,1)) #0
print(AND(1,0)) #0
print(AND(1,1)) #1
</code></pre>
<p><strong>权重w<sub>1</sub>和w<sub>2</sub>是控制输入信号的重要性的参数，而偏置b是调整神经元被激活的容易程度的参数</strong></p>
<!-- more -->
<ol start="4">
<li>使用权重和偏置实现<code>NAND</code>门</li>
</ol>
<pre><code class="language-cpp">def NAND(x1, x2):
    x = np.array([x1, x2])     
    w = np.array([0.5, 0.5]) 
    b = -0.7                 
    flg = np.sum(w * x)
    if np.sum(w * x) + b &gt; 0:
        return 0
    else:
        return 1
</code></pre>
<!-- more -->
<ol start="5">
<li>使用权重和偏置实现<code>OR</code>门</li>
</ol>
<pre><code class="language-cpp">def OR(x1, x2):
x = np.array([x1, x2])
w = np.array([0.5, 0.5])
b = -0
if np.sum(w * x) + b &gt; 0:
    return 1
else:
    return 0
</code></pre>
<p><strong>单层感知机的局限性：无法实现和应用非线性空间的逻辑门</strong></p>
<!-- more -->
<h1 id="part-2多层感知机">Part 2.多层感知机</h1>
<!-- more -->
<p><code>XOR</code>门的实现(叠加了两层感知机)</p>
<pre><code class="language-cpp">def XOR(x1, x2):
    s1 = NAND(x1, x2)
    s2 = OR(x1, x2)
    if AND(s1, s2):
        return 1
    else:
        return 0
</code></pre>
<p>该2层感知机中，x<sub>1</sub>和x<sub>2</sub>作为初始的0层信号发送至1层感知机，然后在第1层和第2层之间进行信号的传送和接收，具体如下：</p>
<ol>
<li>第0层的两个神经元接收输入信号，并将信号发送至第1层的神经元</li>
<li>第1层的神经元将信号发送至第2层的神经元，第2层的神经元输出结果</li>
</ol>
<h1 id="part-3-总结">Part 3. 总结</h1>
<ul>
<li>感知机是具有输入和输出的算法。给定一个输入后，将输出一个既定的值</li>
</ul>
<!-- more -->
<ul>
<li>感知机将权重和偏置设置为参数</li>
</ul>
<!-- more -->
<ul>
<li>使用感知机可以表示与门和或门等逻辑电路</li>
</ul>
<!-- more -->
<ul>
<li>异或门无法通过单层感知机来表示</li>
</ul>
<!-- more -->
<ul>
<li>使用2层感知机可以表示异或门</li>
</ul>
<!-- more -->
<ul>
<li>单层感知机只能表示线性空间，而多层感知机可以表示非线性空间</li>
</ul>
<!-- more -->
<ul>
<li>多层感知机理论上可以表示计算机</li>
</ul>
<!-- more -->
<p><strong>完整基本逻辑门代码</strong></p>
<pre><code class="language-cpp">import numpy as np
def AND(x1, x2):
    x = np.array([x1, x2])     
    w = np.array([0.5, 0.5]) 
    b = -0.7                 
    if np.sum(w * x) + b &gt; 0:
        return 1
    else:
        return 0
    
def NAND(x1, x2):
    x = np.array([x1, x2])     
    w = np.array([0.5, 0.5]) 
    b = -0.7                 
    flg = np.sum(w * x)
    if np.sum(w * x) + b &gt; 0:
        return 0
    else:
        return 1
    
def OR(x1, x2):
    x = np.array([x1, x2])
    w = np.array([0.5, 0.5])
    b = -0
    if np.sum(w * x) + b &gt; 0:
        return 1
    else:
        return 0

def XOR(x1, x2):
    s1 = NAND(x1, x2)
    s2 = OR(x1, x2)
    if AND(s1, s2):
        return 1
    else:
        return 0
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[用Matplotlib在Python中绘制图像]]></title>
        <id>https://CTerena.github.io/post/yong-matplotlib-zai-python-zhong-hui-zhi-tu-xiang/</id>
        <link href="https://CTerena.github.io/post/yong-matplotlib-zai-python-zhong-hui-zhi-tu-xiang/">
        </link>
        <updated>2021-10-09T06:18:13.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<!-- more -->
<!-- more -->
<!-- more -->
<!-- more -->
<!-- more -->
<!-- more -->
<!-- more -->
<!-- more -->
<!-- more -->
<!-- more -->
<!-- more -->
<p>Matplotlib是Python中用于绘制图形的库，可实现数据的可视化<br>
<code>import numpy as np</code><br>
<code>import matplotlib.pyplot as plt</code></p>
<!-- more -->
<p>示例：绘制sin(x)曲线</p>
<pre><code class="language-cpp">x = np.arange(0,10,0.01)
y = sin(x)
plt.plot(x , y)
plt.show()
</code></pre>
<p>这里生成了[0, 0.1, 0.2, ... , 5.8, 5.9]的数据，将其设为x。对x的各个元素，应用NumPy的sin函数，将x、y的数据传给<code>plt.plot</code>方法，然后绘制图形。最后，通过plt.show()显示图形。运行上述代码后，就会显示如下图形：<br>
<img src="https://CTerena.github.io/post-images/1633761147270.png" alt="" loading="lazy"></p>
<p>对于刚才的sin(x)图像，我们可以使用pyplot的添加标题和坐标轴标签等功能,同时追加cos(x)的图像。</p>
<pre><code class="language-cpp">import numpy as np
import matplotlib.pyplot as plt

x = np.arange(0, 10, 0.01)
y1 = np.sin(x)
y2 = np.cos(x)
plt.plot(x, y1, label = 'sin')#label命名
plt.plot(x, y2, linestyle = '--', label = 'cos')#linestyle设置为虚线
plt.xlabel('x')#x轴命名
plt.ylabel('y')#y轴命名
plt.title('sin&amp;cos')
plt.legend()#曲线名称标注
plt.show()
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://CTerena.github.io/post-images/1633761661731.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[MATLAB程序设计语言基础]]></title>
        <id>https://CTerena.github.io/post/matlab-cheng-xu-she-ji-yu-yan-ji-chu/</id>
        <link href="https://CTerena.github.io/post/matlab-cheng-xu-she-ji-yu-yan-ji-chu/">
        </link>
        <updated>2021-10-08T11:35:07.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<!-- more -->
<!-- more -->
<!-- more -->
<!-- more -->
<!-- more -->
<!-- more -->
<!-- more -->
<!-- more -->
<!-- more -->
<!-- more -->
<!-- more -->
<!-- more -->
<!-- more -->
<h1 id="part-1-matlab语言的变量与常量">Part 1. MATLAB语言的变量与常量</h1>
<p>MATLAB语言变量名由字母引导，可包含字母、数字、下划线，且变量名区分大小写。<br>
在MATLAB语言中为特定常数保留了一些名称，虽然这些常量也可以重新赋值，但一般不建议。</p>
<ul>
<li><code>eps</code> ——机器的浮点运算误差限。eps默认值为2.2204e-16，若某个量的绝对值小于eps，则在程序运算中认为这个量为零</li>
<li><code>i</code>和<code>j</code>——表示纯虚数量 j。</li>
<li><code>Inf</code>——无穷大量的MATLAB表示，也可以写作<code>inf</code>。同样地，可用<code>-Inf</code>表示负无穷。在MATLAB程序执行时，即使遇到了以0为除数的运算，也不会终止程序运行，只会给出一个“除0”警告，并将结果赋值为inf。</li>
<li><code>NaN</code>——not a number，通常由0/0运算、Inf/Inf及类似的运算得出。</li>
<li><code>pi</code>——圆周率的双精度浮点表示</li>
<li><code>lasterr</code>——存放最新一次的错误信息。此变量为字符串类型，若无错误，则该变量为空字符串</li>
<li><code>lastwarn</code>——存放最新的警告信息。</li>
</ul>
<h1 id="part-2-基本语句结构">Part 2. 基本语句结构</h1>
<h2 id="1-直接赋值语句">1. 直接赋值语句</h2>
<p>基本结构位<code>赋值变量=赋值表达式</code>。如果赋值表达式后面没有分号，则将在MATLAB命令窗口中显示表达式的运算结果。如果省略了赋值变量和等号，则表达式运算的结果直接赋给保留变量<code>ans</code>。也就是说，<code>ans</code>将永远存放最近一次无赋值变量语句的运算结果。</p>
<h2 id="2函数调用语句">2.函数调用语句</h2>
<p>基本结构为<code>[返回变量列表]=函数名(输入变量列表)</code>，其中，函数名的要求与变量名的要求一致。<br>
返回变量列表和输入变量列表均可以由若干个变量名组成，它们之间用逗号分隔。返回变量还允许用空格分隔。</p>
<h1 id="part-3-冒号表达式与子矩阵提取">Part 3. 冒号表达式与子矩阵提取</h1>
<p>冒号表达式的基本结构为 <code>v = s1 : s2 : s3</code>，该函数将生成一个向量<strong>v</strong>，其中s1为向量的起始值，s2为步距，s3为最大值。若省略s2，则步距为默认值1.</p>
<!-- more -->
<p>提取子矩阵的方法是<code>B = A(v1 , v2)</code>，其中，v1向量表示子矩阵中要保留的行号构成的向量，v2表示保留的列号构成的向量</p>
<h1 id="part-4-基本数学运算">Part 4. 基本数学运算</h1>
<h2 id="1-矩阵的代数运算">1. 矩阵的代数运算</h2>
<ul>
<li><strong>矩阵转置</strong> 使用<code>A'</code>可以得到<strong>A</strong>矩阵的Hermit转置</li>
<li><strong>加减法运算</strong> 假设在MATLAB工作环境下有两个矩阵<strong>A</strong>和<strong>B</strong>，则可以由<code>C = A + B</code>命令执行矩阵加法。若<strong>A</strong>和<strong>B</strong>矩阵的维数相同，可正常运算。若其中之一为标量，则将自动遍加给另一矩阵。其他情况下报错。</li>
<li><strong>矩阵乘法</strong> 维数相容的两个矩阵的乘法可直接由<code>C = A + B</code>算得</li>
<li><strong>矩阵左除</strong> MATLAB中用&quot;&quot;运算符号表示两个矩阵的左除，A\B为方程 <strong>AX = B</strong>的解<strong>X</strong>，若<strong>A</strong>为非奇异方阵（可逆方阵），则 <strong>X = A<sup>-1</sup>B</strong></li>
<li><strong>矩阵翻转</strong>MATLAB提供一些翻转矩阵的特殊命令，如<code>B = fliplr(A)</code>命令将矩阵A左右翻转再赋给B，<code>B = flipud(A)</code>将</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Pandas库使用指南]]></title>
        <id>https://CTerena.github.io/post/pandas-ku-shi-yong-zhi-nan/</id>
        <link href="https://CTerena.github.io/post/pandas-ku-shi-yong-zhi-nan/">
        </link>
        <updated>2021-10-08T01:29:38.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<!-- more -->
<!-- more -->
<!-- more -->
<!-- more -->
<!-- more -->
<!-- more -->
<!-- more -->
<!-- more -->
<!-- more -->
<!-- more -->
<!-- more -->
<!-- more -->
<!-- more -->
<h2 id="概述">概述</h2>
<p>Pandas(panel data,面板数据)是在Numpy基础上开发的数据分析工具，该工具库可以用于解决数据的预处理问题，如数据类型的转换、缺失值的处理、描述性统计分析、数据的汇总等.</p>
<!-- more -->
<p>Pandas数据结构的范围可以从一维到三维。Series（序列）是一维的，DataFrame（数据框）是二维的，Panel是更高维的数据结构。<br>
Series是一个带标签的一维数组，可以存储任意类型的数据，它的行标签称作index<br>
DataFrame是一个带标签的二维数组，有行和列。列可以有很多类型。DataFrame也可以看作包含多个不同类型的Series的集合<br>
Panel：在统计学与经济学中，Panel data（面板数据）指多维数据，这个多维数据包括不同时间的不同测量结果。与Series和FrameData相比，面板数据是不太常用的一种数据结构</p>
<h1 id="part-1-series">Part 1. Series</h1>
<p>构造一个序列可以使用以下方式实现：</p>
<ol>
<li>通过同类型的列表或元组构建</li>
<li>通过字典构建</li>
<li>通过Numpy中的一维数组构建</li>
<li>通过数据框中的某一列构建</li>
</ol>
<p>序列构造示例：<br>
<code>import pandas as pd</code><br>
<code>import numpy as np</code></p>
<pre><code class="language-cpp">s1 = pd.Series(np.array([101,202,303]))#由一维数组构造
s2 = pd.Series({'CS':101,'MATH':220,'CHEM':102})#由字典构造
s3 = pd.Series([101,202,303],index=['A','B','C'])#用行标签命名
</code></pre>
<p>对应的结果：</p>
<pre><code class="language-cpp">0    101
1    202
2    303
dtype: int32
---------
CS      101
MATH    220
CHEM    102
dtype: int64
---------
A    101
B    202
C    303
dtype: int64
</code></pre>
<p>序列与一维数组相似，获取一维数组元素的方法都可以应用于序列，且数组的数学和统计函数也可以应用到序列对象上，不同的是，序列拥有更多的处理方法</p>
<!-- more -->
<p>Pandas序列中可以进行统计特征计算，包括均值、方差、分位数、相关系数和协方差等，这些统计特征能反映数据的整体分布.<br>
<code>mean()</code>用于计算样本数据的算术平均值</p>
<!-- more -->
<p><code>std()</code>用于计算样本数据的标准差</p>
<!-- more -->
<p><code>cov()</code>用于计算样本数据的协方差矩阵</p>
<!-- more -->
<p><code>var()</code>用于计算样本数据的方差</p>
<!-- more -->
<p><code>describe()</code>用于描述样本数据的基本情况，包括非NaN数据个数，均值，标准差，最小值，最大值以及样本的25%，50%，75%分位数</p>
<p>序列索引与计算示例：</p>
<pre><code class="language-cpp">import pandas as pd
s = pd.Series([101,202,303],index=['A','B','C'])
print(s['C'])
print(s.mean())
print(s.var())
</code></pre>
<p>结果：</p>
<pre><code class="language-cpp">303
202.0
10201.0
</code></pre>
<h1 id="part-2-dataframe">Part 2. DataFrame</h1>
<p>DataFrame是由行和列构成的二维数据结构。索引可以看作行标签，列名称可以看作列标签</p>
<!-- more -->
<p>数据框的构造方法如下：<br>
<code>DataFrame(data=二维数据, index=行索引,columns=列索引, dtype=数据类型)</code><br>
其中“二维数据”可以是二维Numpy数组，后三项可选择性填写</p>
<!-- more -->
<p>DataFrame构建示例：</p>
<pre><code class="language-cpp">import pandas as pd
import numpy as np

a = np.array([[1,2,3],
              [4,5,6],
              [7,8,9]])

df1 = pd.DataFrame(a)
df2 = pd.DataFrame(a,index=['一','二','三'],columns=['壹','贰','参'])
print('df1:')
print(df1)
print('df2:')
print(df2)
</code></pre>
<p>结果：</p>
<pre><code class="language-cpp">df1:
   0  1  2
0  1  2  3
1  4  5  6
2  7  8  9
df2:
   壹  贰  参
一  1  2  3
二  4  5  6
三  7  8  9
</code></pre>
<h1 id="part-3文本文件的读取">Part 3.文本文件的读取</h1>
<p>实际应用中，更多的情况是通过Python读取外部数据，这些数据可能是文本文件（如csv、txt等）和电子表格等<br>
Pandas库中的read_csv函数，可以读取txt或csv（逗号分隔的文本文件）的文本格式数据</p>
<!-- more -->
<p><strong>参考文献</strong><br>
[1]司守奎，孙玺青. Python数学实验与建模. 北京：科学出版社，2020</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[线性代数中的线性方程组（一）]]></title>
        <id>https://CTerena.github.io/post/xian-xing-dai-shu-zhong-de-xian-xing-fang-cheng-zu-yi/</id>
        <link href="https://CTerena.github.io/post/xian-xing-dai-shu-zhong-de-xian-xing-fang-cheng-zu-yi/">
        </link>
        <updated>2021-10-07T15:18:10.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<!-- more -->
<!-- more -->
<!-- more -->
<!-- more -->
<!-- more -->
<!-- more -->
<!-- more -->
<!-- more -->
<!-- more -->
<!-- more -->
<!-- more -->
<!-- more -->
<!-- more -->
<!-- more -->
<h1 id="part-1-概念">Part 1. 概念</h1>
<!-- more -->
<p> 1.包含变量x<sub>1</sub>,x<sub>2</sub>,...x<sub>n</sub>的<strong>线性方程</strong>是形如<br>
                                                     a<sub>1</sub>x<sub>1</sub>+ a<sub>2</sub>x<sub>2</sub>+...+ a<sub>n</sub>x<sub>n</sub>=b<br>
  的方程</p>
<!-- more -->
<p> 2.<strong>线性方程组</strong>是由一个或几个包含相同变量x<sub>1</sub>,x<sub>2</sub>,...x<sub>n</sub>的线性方程组成的</p>
<!-- more -->
<p> 3.线性方程组的<strong>解</strong>是一组数（s<sub>1</sub>,s<sub>2</sub>,...,s<sub>n</sub>),用这组数分别替代x<sub>1</sub>,x<sub>2</sub>,...x<sub>n</sub>时所有方程的两边相等</p>
<!-- more -->
<p> 4.方程组所有可能的解的集合称为线性方程组的<strong>解集</strong></p>
<!-- more -->
<p> 5.若两个线性方程组有相同的解集，则这两个线性方程组称为<strong>等价的</strong></p>
<p>  6.线性方程组的解有下列三种情况：<br>
   1. 无解<br>
   2. 有唯一解<br>
   3. 有无穷多解</p>
<!-- more -->
<p> 7.有一个或无穷多个解的线性方程组是<strong>相容的</strong>；无解的线性方程组是<strong>不相容的</strong></p>
<!-- more -->
<p> 8.由变量系数组成的矩阵称为<strong>系数矩阵</strong></p>
<!-- more -->
<p> 9.由变量系数和常数项组成的矩阵称为<strong>增广矩阵</strong></p>
<!-- more -->
<p> 10.<strong>初等行变换</strong><br>
  1. （倍加变换）把某一行换成它本身和另一行的倍数的和<br>
  2. （对换变换）把两行对换<br>
  3. （倍乘变换）把某一行的所有元素乘以同一个非零数</p>
<!-- more -->
<p> 11.若两个矩阵中的一个能经初等行变换变换为另一个矩阵，则成这两个矩阵为<strong>行等价的</strong>，它们具有相同的解集</p>
<!-- more -->
<p> 12.一个矩阵称为<strong>阶梯形（REF)</strong>，当它有以下三个性质：<br>
  1. 每一非零行都在每一零行之上<br>
  2. 某一行的先导元素所在的列位于前一行先导元素的右边<br>
  3.某一先导元素所在列下方元素都是零</p>
<!-- more -->
<p> 13.若一个阶梯形矩阵还满足以下性质，则称它为<strong>简化阶梯形(RREF)</strong><br>
  1.每一非零行的先导元素是1<br>
  2.每一先导元素1是该元素所在列的唯一非零元素</p>
<p> 14.矩阵中的<strong>主元位置</strong>是其中对应于它的阶梯形中先导元素1的位置</p>
<!-- more -->
<p> 15.<strong>主元列</strong>是A的含有主元位置的列</p>
<!-- more -->
<p> 16.将矩阵化简为REF的步骤称为<strong>向前步骤</strong>，将REF化简为RREF的步骤称为<strong>向后步骤</strong></p>
<!-- more -->
<p> 17.对应于主元列的变量称为<strong>基本变量</strong>；其它变量称为<strong>自由变量</strong></p>
<!-- more -->
<p> 18.仅含一列的矩阵称为<strong>列向量</strong>，简称<strong>向量</strong>，所有元素都是零的向量称为<strong>零向量</strong><br>
 19.给定R</p>
<h1 id="part-2-定理">Part 2. 定理</h1>
<p> <strong>定理1</strong>：<em>每个矩阵行等价于唯一的简化阶梯形矩阵</em></p>
<!-- more -->
<p> <strong>定理2（存在与唯一性定理）</strong>：<em>线性方程组相容的充要条件是增广矩阵的最右列不是主元列</em></p>
<h1 id="part-3-方法">Part 3. 方法</h1>
<p> <strong>应用行化简算法求解线性方程组</strong><br>
  1. 写出方程的增广矩阵<br>
  2.应用行化简算法把增广矩阵化为阶梯形；确定方程组是否相容，若否则停止<br>
  3.继续行化简算法得到它的简化阶梯形<br>
  4.写出由第三步得到的矩阵对应的方程组<br>
  5.把第四步所得的每个非零方程改写为用任意自由变量表示其基本变量的形式</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[树链剖分 (QTREE) 学习笔记]]></title>
        <id>https://CTerena.github.io/post/shu-lian-pou-fen-xue-xi-bi-ji/</id>
        <link href="https://CTerena.github.io/post/shu-lian-pou-fen-xue-xi-bi-ji/">
        </link>
        <updated>2021-10-07T13:49:28.000Z</updated>
        <content type="html"><![CDATA[<h1 id="part1-树链剖分的功能">Part1. 树链剖分的功能</h1>
<p>对一棵树分成几条链，把树形变为线性，减少处理难度<br>
需要处理的问题：</p>
<p>1. 将树从x到y结点最短路径上所有节点的值都加上z</p>
<p>2. 求树从x到y结点最短路径上所有节点的值之和</p>
<p>3. 将以x为根节点的子树内所有节点值都加上z</p>
<p>4. 求以x为根节点的子树内所有节点值之和</p>
<h1 id="part2-相关概念">Part2. 相关概念</h1>
<ol>
<li>
<p>重儿子：对于每一个非叶子节点，它的儿子中以那个儿子为根的子树节点数（包括自身）最大的儿子为该节点的重儿子</p>
</li>
<li>
<p>轻儿子：非重儿子</p>
</li>
<li>
<p>重边：一个父节点与其重儿子的连边</p>
</li>
<li>
<p>轻边：非重边</p>
</li>
<li>
<p>重链：相邻重边相连形成的链</p>
</li>
</ol>
<p>  tips：叶子结点若为轻儿子，则自成一条长度为1的链</p>
<p>  重链以轻儿子或根节点为起点</p>
<h1 id="part3-常规操作">Part3. 常规操作</h1>
<p>1.预处理</p>
<p>（1）dfs1：</p>
<p>   处理： 各点深度；  各点重儿子编号； 各点最大子树大小 ；各点父亲</p>
<p>代码：</p>
<pre><code class="language-cpp">void dfs1(int now,int fa,int deep)
{
    siz[now]=1;
    fat[now]=fa;
    dep[now]=deep;
    zs=-1;
    for(int i=head[now];i;i=nxt[i])
    {
        if(to[i]==now)
            continue; //别忘了 
        dfs1(to[i],now,deep+1);
        siz[now]+=siz[to[i]];
        if(siz[to[i]]&gt;zs)//处理重儿子 
            zhoson[now]=to[i],zs=siz[to[i]];
    }
}
</code></pre>
<p>（2）dfs2</p>
<p>处理：</p>
<p>标记每个点的新编号（线段树中编号）</p>
<p>赋值每个点的初始值到新编号上</p>
<p>处理每个点所在链的顶端</p>
<p>处理每条链</p>
<p>顺序规定：先重后轻</p>
<p>代码：</p>
<pre><code class="language-cpp">void dfs2(int now,int top)
{
    tp[now]=top;
    id[now]=++cnt;
    wt[cnt]=w[x];
    if(!zhoson[now])
        return;
    dfs2(zhoson[now],top);
    for(int i=head[now];i;i=nxt[i])
    {
        if(to[i]==fat[now]||to[i]==zhoson[now])
            continue;
        dfs2(to[i],to[i]);
    }
} 
</code></pre>
<p>2.功能实现</p>
<p>1.查询两点间距离</p>
<p>方法：每次选定两点所在链中深度较大的，加上它到其链起点的权值，然后跳到链起点的父节点重复操作，直至两点在同一条链上。</p>
<p></p>
<pre><code class="language-cpp">int qiurange(int x,int y)
{
    int ans=0;
    while(top[x]!=top[y])
    {
        if(deep[top[x]]&lt;deep[top[y]])
            swap(x,y);
        res=0;
        query(1,1,n,tid[top[x]],tid[x]);
        ans=(ans+res)%mod;
        x=fat[top[x]];
    }

    if(deep[x]&gt;deep[y])
    swap(x,y);
    res=0;
    query(1,1,n,tid[x],tid[y]);
    ans=(ans+res)%mod;
    return ans;
}
</code></pre>
<p>2.两点间路径修改：</p>
<p>同1，反复跳并update（线段树）</p>
<pre><code class="language-cpp">void uprange(int x,int y,int k)
{
    k%=mod;
    while(top[x]!=top[y])
    {
        if(deep[top[x]]&lt;deep[top[y]])
        swap(x,y);
        update(1,1,n,tid[top[x]],tid[x],k);
        x=fat[top[x]];
    }
    if(deep[x]&gt;deep[y])
    swap(x,y);
    update(1,1,n,tid[x],tid[y],k);
}
</code></pre>
<p>3.子树修改</p>
<p>上边提到过，子树中节点的编号是连续的，因此在线段树上也是一段连续的区间，相当于线段树区间修改</p>
<pre><code class="language-cpp">void updSon(int x,int k)
{
    update(1,1,n,tid[x],tid[x]+siz[x]-1,k);
}
</code></pre>
<p>4.子树查询</p>
<p>只要直接维护即可。（区间的起点是该子树根节点，大小是子树大小）</p>
<pre><code class="language-cpp">int qSon(int x)
{
    res=0;
    query(1,1,n,tid[x],tid[x]+siz[x]-1);
    return res;
}
</code></pre>
<p>完整代码如下，除了上面的部分还要有线段树的基本操作函数：</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#define maxn 100005
#define mid (l+r&gt;&gt;1)
#define len (r-l+1)
#define ls id&lt;&lt;1
#define rs id&lt;&lt;1|1
using namespace std;
int cnt,head[maxn],nxt[maxn &lt;&lt; 1],to[maxn &lt;&lt; 1];
int w[maxn],wt[maxn],tidnum,siz[maxn],deep[maxn],son[maxn],fat[maxn],tid[maxn],top[maxn];
int a[maxn &lt;&lt; 2],laz[maxn &lt;&lt; 2];
int res=0,n,m,r,mod;
void addedge(int x,int y)
{
    to[++cnt]=y;
    nxt[cnt]=head[x];
    head[x]=cnt;
}
void pushdown(int rt,int l,int r)
{
    (laz[rt&lt;&lt;1]+=laz[rt]) %= mod;
    (laz[rt&lt;&lt;1|1]+=laz[rt]) %= mod;
    a[rt&lt;&lt;1]+=laz[rt]*(mid - l + 1);
    a[rt&lt;&lt;1|1]+=laz[rt]*(r - mid);
    a[rt&lt;&lt;1]%=mod;
    a[rt&lt;&lt;1|1]%=mod;
    laz[rt]=0;
}

void build(int id,int l,int r)
{
    if(l==r)
    {
        a[id]=wt[l];
        if(a[id]&gt;mod)
        a[id]%=mod;
        return;
    }
    build(ls,l,mid);
    build(rs,mid+1,r);
    a[id]=(a[id&lt;&lt;1]+a[id&lt;&lt;1|1])%mod;
}

void query(int id,int l,int r,int tol,int tor)
{
    if(tol&lt;=l&amp;&amp;r&lt;=tor)
    {
        res+=a[id];
        res%=mod;
        return;
    }
    else
    {
        if(laz[id])
        pushdown(id,l,r);
        if(tol&lt;=mid)
        query(ls,l,mid,tol,tor);
        if(tor&gt;mid)
        query(rs,mid+1,r,tol,tor);
    }
}

void update(int id,int l,int r,int tol,int tor,int k)
{
    if(tol&lt;=l&amp;&amp;r&lt;=tor)
    {
        laz[id]+=k;
        a[id]+=k*len;
        a[id] %= mod;
        laz[id] %= mod;
    }
    else
    {
        if(laz[id])
        pushdown(id,l,r);
        if(tol&lt;=mid)
        update(ls,l,mid,tol,tor,k);
        if(tor&gt;mid)
        update(rs,mid+1,r,tol,tor,k);
        a[id]=(a[id&lt;&lt;1]+a[id&lt;&lt;1|1])%mod;
    }
}

int qiurange(int x,int y)
{
    int ans=0;
    while(top[x]!=top[y])
    {
        if(deep[top[x]]&lt;deep[top[y]])
            swap(x,y);
        res=0;
        query(1,1,n,tid[top[x]],tid[x]);
        ans=(ans+res)%mod;
        x=fat[top[x]];
    }

    if(deep[x]&gt;deep[y])
        swap(x,y);
    res=0;
    query(1,1,n,tid[x],tid[y]);
    ans=(ans+res)%mod;
    return ans;
}

void uprange(int x,int y,int k)
{
    k%=mod;
    while(top[x]!=top[y])
    {
        if(deep[top[x]]&lt;deep[top[y]])
        swap(x,y);
        update(1,1,n,tid[top[x]],tid[x],k);
        x=fat[top[x]];
    }
    if(deep[x]&gt;deep[y])
    swap(x,y);
    update(1,1,n,tid[x],tid[y],k);
}

int qSon(int x)
{
    res=0;
    query(1,1,n,tid[x],tid[x]+siz[x]-1);
    return res;
}

void updSon(int x,int k)
{
    update(1,1,n,tid[x],tid[x]+siz[x]-1,k);
}

void dfs1(int x,int f,int deeep) 
{
    deep[x]=deeep;
    fat[x]=f;
    siz[x]=1;
    int maxson=-1;
    for(int i=head[x];i;i=nxt[i])
    {
        int y=to[i];
        if(y==f)
        continue;
        dfs1(y,x,deeep+1); 
        siz[x]+=siz[y]; 
        if(siz[y]&gt;maxson)
        son[x]=y,maxson=siz[y];
    }
}

void dfs2(int id,int tp)
{
    tid[id]=++tidnum;
    wt[tidnum]=w[id];
    top[id]=tp;
    if(!son[id])
    return; 
    dfs2(son[id],tp);
    for(int i=head[id];i;i=nxt[i])
    {
        if(to[i]==fat[id]||to[i]==son[id])
        continue;
        dfs2(to[i],to[i]);
    }
}

int main()
{
    scanf(&quot;%d%d%d%d&quot;,&amp;n,&amp;m,&amp;r,&amp;mod);
    for(int i=1;i&lt;=n;i++)
    scanf(&quot;%d&quot;,&amp;w[i]);
    for(int i=1;i&lt;n;i++)
    {
        int a,b;
        scanf(&quot;%d%d&quot;,&amp;a,&amp;b);
        addedge(a,b);
        addedge(b,a);
    }
    dfs1(r,0,1);
    dfs2(r,r);
    build(1,1,n);
    while(m--)
    {
        int t,x,y,z;
        scanf(&quot;%d&quot;,&amp;t);
        if(t==1)
        {
            scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);
            uprange(x,y,z);
        }
        else if(t==2)
        {
            scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
            printf(&quot;%d\n&quot;,qiurange(x,y));
        }
        else if(t==3)
        {
            scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
            updSon(x,y);
        }
        else
        {
            scanf(&quot;%d&quot;,&amp;x);
            printf(&quot;%d\n&quot;,qSon(x));
        }
    }
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[可持久化线段树（prizident tree）学习笔记]]></title>
        <id>https://CTerena.github.io/post/ke-chi-jiu-hua-xian-duan-shu-prizident-treexue-xi-bi-ji/</id>
        <link href="https://CTerena.github.io/post/ke-chi-jiu-hua-xian-duan-shu-prizident-treexue-xi-bi-ji/">
        </link>
        <updated>2021-10-07T13:29:10.000Z</updated>
        <content type="html"><![CDATA[<h1 id="part-1-定义">Part 1. 定义：</h1>
<p>    可持久化：数据结构可以支持回退，访问之前版本的性质<br>
    主席树：可以访问未经过其他操作的版本的线段树</p>
<h1 id="part-2-原理">Part 2. 原理：</h1>
<p>主席树与线段树的基本操作相同，难点在于可持久化的实现。</p>
<p>如果想要访问每个版本的线段树，首先想到的是对线段树进行全盘复制，然后在上个版本的基础上进行本次操作以建立新版本。但很显然如此一来空间复杂度会窜到O（n*m），显然不可行</p>
<p>考虑操作对线段树的作用：每次操作一定不会涉及线段树上所有的节点，而不涉及的节点必然在两        个版本中是相同的，也就是可以共享的</p>
<p>以此为切入点，如果我们在每次进行操作时只修改被影响的节点，可以得到如下的结果（图源洛谷）<img src="https://CTerena.github.io/post-images/1633613428792.png" alt="" loading="lazy"></p>
<p>具体的做法是，进行每次操作时复制上个版本的根作为新版本的根，再递归判断修改的子节点进行修改</p>
<p>代码：</p>
<pre><code class="language-cpp">inline int update(int pre, int l, int r, int x)
{
    int rt=++cnt;
    L[rt]=L[pre]; R[rt]=R[pre]; sum[rt]=sum[pre]+1;
    if (l&lt;r)
    {
        if (x &lt;= mid) L[rt] = update(L[pre], l, mid, x);
        else R[rt]=update(R[pre], mid+1, r, x);
    }
    return rt;
}
</code></pre>
<h1 id="part3-模板题查询静态区间第k小">Part3. 模板题：查询静态区间第k小</h1>
<p>与主席树的联系：把序列从左到右插入到树中，没插入一次对应一个版本，在l——r间查询对应在版本l和r间进行比较查询</p>
<p>建树方法：先把整个序列进行离散化，线段树维护每个数出现过多少次</p>
<p>比较方法：导入两个根，先对两者左儿子中数的个数进行比较，若比k小则说明k在右儿子中，进行递归</p>
<p>完整代码：</p>
<pre><code class="language-cpp">#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#define maxn 200010
#define mid (l + r) / 2
using namespace std;
int ls[maxn &lt;&lt; 5],rs[maxn &lt;&lt; 5],sum[maxn &lt;&lt; 5];
int a[maxn],b[maxn],cnt = 0,t[maxn &lt;&lt; 5];
int n,m,q;
int build(int l,int r)
{
    int rt = ++cnt;
    sum[rt] = 0;
    if(l &lt; r)
    {
        ls[rt] = build(l,mid);
        rs[rt] = build(mid + 1,r);
    }
    return rt;
}
int update(int pre,int l,int r,int k)
{
    int rt = ++cnt;
    ls[rt] = ls[pre];
    rs[rt] = rs[pre];
    sum[rt] = sum[pre] + 1;
    if(l &lt; r)
    {
        if(k &lt;= mid)
            ls[rt] = update(ls[pre],l,mid,k);
        else
            rs[rt] = update(rs[pre],mid + 1,r,k);
    }
    return rt;
}
int query(int u,int v,int l,int r,int k)
{
    if(l &gt;= r)
        return l;
    int usm = sum[ls[v]]-sum[ls[u]];
    if(k &lt;= usm)
        return query(ls[u],ls[v],l,mid,k);
    else
        return query(rs[u],rs[v],mid + 1,r,k - usm);
}
int main()
{
    scanf(&quot;%d%d&quot;,&amp;n,&amp;q);
    for(int  i = 1;i &lt;= n;i++)    
    {
        scanf(&quot;%d&quot;,&amp;a[i]);
        b[i] = a[i];
    }
    sort(b + 1,b + n + 1);
    m = unique(b + 1,b + n + 1) - b - 1;
    t[0] = build(1,m);
    for(int i = 1;i &lt;= n;i++)
    {
        int p = lower_bound(b + 1,b + m + 1,a[i]) - b;
        t[i] = update(t[i - 1],1,m,p);
    }
    while(q--)
    {
        int x,y,z;
        scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);
        printf(&quot;%d\n&quot;,b[query(t[x - 1],t[y],1,m,z)]);
    }
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python中的文件操作]]></title>
        <id>https://CTerena.github.io/post/python-zhong-de-wen-jian-yun-suan/</id>
        <link href="https://CTerena.github.io/post/python-zhong-de-wen-jian-yun-suan/">
        </link>
        <updated>2021-10-07T05:29:17.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<!-- more -->
<!-- more -->
<!-- more -->
<!-- more -->
<!-- more -->
<!-- more -->
<!-- more -->
<!-- more -->
<!-- more -->
<!-- more -->
<!-- more -->
<!-- more -->
<p>概述：文件是计算机中由操作系统管理的具有名字的存储区域<br>
借助Python内置的open函数，我们可通过程序对计算机上已有的文件进行读写，也可以创建新文件并赋予其任意内容</p>
<h1 id="part-1-打开文件">Part 1. 打开文件🚗</h1>
<p> 操作：<code>myfile = open('file.txt','r')</code><br>
 为了打开一个文件，程序要调用open函数，内部参数首先是文件名，接着是处理模式。处理模式中，<code>'r'</code>代表输入打开文件，<code>'w'</code>代表输出生成并打开文件，<code>'a'</code>代表在打开文件并在文件尾部追加内容，若想对一个文件同时进行读写操作，可使用<code>'r+'</code>。若不填写处理模式，则默认为<code>'r'</code><br>
<strong>注意：关闭文件：<code>myfile.close()</code>调用close函数将会终止对外部文件的链接，手动关闭文件不是必要的，但是一个很好的习惯，可以有效地防止文件数据丢失或篡改</strong></p>
<h1 id="part-2-读取文件内容">Part 2. 读取文件内容🛴</h1>
<!-- more -->
<ul>
<li><code>mydata = myfile.read()</code>  将整个文件读进单一字符串<br>
使用read()读取将会返回一个包含文件全部内容（包括行末标识符）的字符串</li>
</ul>
<!-- more -->
<ul>
<li><code>mydata = myfile.readline()</code>  读取下一行（包括行末标识符）到一个字符串<br>
从第一行开始，每次使用readline会自动读取下一行的全部内容，以字符串形式返回</li>
</ul>
<!-- more -->
<ul>
<li><code>mydata = myfile.readlines()</code> 读取整个文件到字符串列表<br>
生成一个元素数等于文件行数的列表，列表中的每一元素为文件中一行全部内容的字符串</li>
</ul>
<p>使用演示：</p>
<p>以三种方法读取以下文件：<br>
<img src="https://CTerena.github.io/post-images/1633588030389.png" alt="" loading="lazy"></p>
<ol>
<li>read()</li>
</ol>
<pre><code class="language-cpp">    myfile = open('sonnet 18.txt','r')
    mydata = myfile.read()
    myfile.close()
    print(type(mydata))
    print(mydata)
</code></pre>
<p>结果：</p>
<pre><code class="language-cpp">    &lt;class 'str'&gt;
    So long as men can breathe, or eyes can see,
    So long lives this, and this gives life to thee.
</code></pre>
<!-- more -->
<p>2.readline()</p>
<pre><code class="language-cpp">    myfile = open('sonnet 18.txt','r')
    mydata1 = myfile.readline()
    mydata2 = myfile.readline()
    myfile.close()
    print(type(mydata1))
    print('第一行：%s' % mydata2)
    print('第二行：%s' % mydata1)
</code></pre>
<p>结果：</p>
<pre><code class="language-cpp">    &lt;class 'str'&gt;
    第一行：So long lives this, and this gives life to thee.
    第二行：So long as men can breathe, or eyes can see,
</code></pre>
<!-- more -->
<p>3.readlines()</p>
<pre><code class="language-cpp">    myfile = open('sonnet 18.txt','r')
    mydata = myfile.readlines()
    myfile.close()
    print(type(mydata))
    print(mydata)

    print(mydata[1])
</code></pre>
<p>结果：</p>
<pre><code class="language-cpp">    &lt;class 'list'&gt;
    ['So long as men can breathe, or eyes can see,\n', 'So long lives this, and this gives life to thee.']
    So long lives this, and this gives life to thee.
</code></pre>
<h1 id="part-3-处理文件内容">Part 3. 处理文件内容🚲</h1>
<p>实际办公编程中，我们常常不仅需要读取文件的所有内容，更需要对其中的重要信息进行提取归纳。这需要我们掌握一些进阶的字符串处理操作：</p>
<p><strong>例1</strong> 提取所有作家的名字：<br>
<img src="https://CTerena.github.io/post-images/1633590885680.png" alt="" loading="lazy"><br>
    可以注意到，该文件中作家名字被逗号和换行符分开，为提取单个作家名字，可以使用<code>split()</code>函数<br>
    * <code>split()</code>函数用法：通过切除字符串中的指定字符将字符串拆分成多个并以列表形式存储，如下：</p>
<pre><code class="language-cpp">    str = 'A rose,is a rose,is a rose,is a rose'
    lis = str.split(',')
    print(lis)
</code></pre>
<p>    结果：</p>
<pre><code class="language-cpp">    ['A rose', 'is a rose', 'is a rose', 'is a rose']
</code></pre>
<p>    该例中，我们使用<code>split()</code>以逗号为隔断将字符串拆成多个。而为了处理上方的作家名问    题，我们需要分别以换行符和逗号作为隔断，顺便一提，换行符的表示方法是<code>'\n'</code></p>
<pre><code class="language-cpp">    myfile = open('2021诺贝尔文学奖预测.txt','r')
    mydata = myfile.read() #全部读取
    print(mydata,'\n') 

    mydata = mydata.split('\n') #以换行符为隔断
    print(mydata,'\n') 

    for row in mydata: #枚举列表元素，相当于枚举原文件每行（字符串形式）
        name = row.split(',') #在该行中以逗号为隔断
        for i in range(0,len(name)): #输出名字
            print(name[i])
</code></pre>
<p>    结果：</p>
<pre><code class="language-cpp">    Murakami,Ngugi,Carson,Ulitskaya
    Atwood,Krasznahorkai,Lillo
    Oates,Pynchon,CanXue,Houellebecq
    YanLianke,Elena,Kincaid 

    ['Murakami,Ngugi,Carson,Ulitskaya', 'Atwood,Krasznahorkai,Lillo', 'Oates,   Pynchon,CanXue,Houellebecq', 'YanLianke,Elena,Kincaid'] 

    Murakami
    Ngugi
    Carson
    Ulitskaya
    Atwood
    Krasznahorkai
    Lillo
    Oates
    Pynchon
    CanXue
    Houellebecq
    YanLianke
    Elena
    Kincaid
</code></pre>
<p><strong>例2</strong> 将每一行的词语连成一句话：<br>
<img src="https://CTerena.github.io/post-images/1633593025159.png" alt="" loading="lazy"><br>
     首先，我们可通过<code>split()</code>将词语归纳到一个列表中：</p>
<pre><code class="language-cpp">    myfile = open('An American folk.txt','r')
    mydata = myfile.read()
    mydata = mydata.split('\n')
</code></pre>
<p>     此时，<code>mydata</code>为<code>['May', 'your', 'days', 'be', 'fragrant,', 'And may', 'all', 'your', 'Christamses', 'be', 'merry', 'and bright.']</code></p>
<!-- more -->
<p>     借着，我们可借助<code>join()</code>函数将这些词语连为一句：</p>
<pre><code class="language-cpp">    folk = ' '.join(mydata)
    print(folk)
</code></pre>
<p>     结果：</p>
<pre><code class="language-cpp">May your days be fragrant, And may all your Christamses be merry and bright.
</code></pre>
<h1 id="part-4-写入文件内容">Part 4. 写入文件内容🚝</h1>
<p>     <code>myfile.write(xxx)</code> 写入字节字符串到文件，以课件为例：<br>
<img src="https://CTerena.github.io/post-images/1633594109676.png" alt="" loading="lazy"><br>
（<code>open('poem.txt','w')</code>会创建了一个新文件poem.txt）<br>
另外，可以通过<code>writelines()</code>将列表内容按行写入文件：</p>
<pre><code class="language-cpp">L = ['Wee ', 'Liat ', 'speaks ', 'so his mother ', 'fast ']

myfile = open('Wee.txt','w')
myfile.writelines(L)

myfile.close()
</code></pre>
<p>即可得到文件：<br>
<img src="https://CTerena.github.io/post-images/1633594483848.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
</feed>